using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Prim.Roslyn
{
    /// <summary>
    /// Source generator that transforms methods marked with [Continuable]
    /// to support suspension, state capture, and resumption.
    ///
    /// Note: This is a simplified implementation that demonstrates the concept.
    /// A production implementation would need more sophisticated syntax tree
    /// transformation to handle all C# constructs.
    /// </summary>
    [Generator]
    public class ContinuationGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Find all methods with [Continuable] attribute
            var methodDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsCandidateMethod(s),
                    transform: static (ctx, _) => GetMethodIfContinuable(ctx))
                .Where(static m => m is not null);

            // Combine with compilation
            var compilationAndMethods = context.CompilationProvider.Combine(methodDeclarations.Collect());

            // Generate source
            context.RegisterSourceOutput(compilationAndMethods,
                static (spc, source) => Execute(source.Left, source.Right, spc));
        }

        private static bool IsCandidateMethod(SyntaxNode node)
        {
            return node is MethodDeclarationSyntax m && m.AttributeLists.Count > 0;
        }

        private static MethodDeclarationSyntax GetMethodIfContinuable(GeneratorSyntaxContext context)
        {
            var methodSyntax = (MethodDeclarationSyntax)context.Node;

            foreach (var attributeList in methodSyntax.AttributeLists)
            {
                foreach (var attribute in attributeList.Attributes)
                {
                    var name = attribute.Name.ToString();
                    if (name == "Continuable" || name == "ContinuableAttribute" ||
                        name.EndsWith(".Continuable") || name.EndsWith(".ContinuableAttribute"))
                    {
                        return methodSyntax;
                    }
                }
            }

            return null;
        }

        private static void Execute(
            Compilation compilation,
            ImmutableArray<MethodDeclarationSyntax> methods,
            SourceProductionContext context)
        {
            if (methods.IsDefaultOrEmpty)
                return;

            var methodsByType = methods
                .Where(m => m is not null)
                .GroupBy(m => GetFullTypeName(m))
                .ToList();

            foreach (var group in methodsByType)
            {
                var typeName = group.Key;
                var source = GenerateTransformedMethods(typeName, group.ToList(), compilation);
                context.AddSource($"{typeName.Replace(".", "_")}_Continuations.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        }

        private static string GetFullTypeName(MethodDeclarationSyntax method)
        {
            var typeDecl = method.Parent as TypeDeclarationSyntax;
            if (typeDecl == null) return "UnknownType";

            var typeName = typeDecl.Identifier.Text;
            var ns = GetNamespace(typeDecl);

            return string.IsNullOrEmpty(ns) ? typeName : $"{ns}.{typeName}";
        }

        private static string GetNamespace(SyntaxNode node)
        {
            var ns = node.Ancestors()
                .OfType<BaseNamespaceDeclarationSyntax>()
                .FirstOrDefault();

            return ns?.Name.ToString() ?? "";
        }

        private static string GenerateTransformedMethods(
            string typeName,
            System.Collections.Generic.List<MethodDeclarationSyntax> methods,
            Compilation compilation)
        {
            var sb = new StringBuilder();

            var lastDot = typeName.LastIndexOf('.');
            var ns = lastDot > 0 ? typeName.Substring(0, lastDot) : null;
            var shortTypeName = lastDot > 0 ? typeName.Substring(lastDot + 1) : typeName;

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#nullable disable");
            sb.AppendLine("#pragma warning disable CS0162 // Unreachable code detected");
            sb.AppendLine();
            sb.AppendLine("using System;");
            sb.AppendLine("using Prim.Core;");
            sb.AppendLine("using Prim.Runtime;");
            sb.AppendLine();

            if (!string.IsNullOrEmpty(ns))
            {
                sb.AppendLine($"namespace {ns}");
                sb.AppendLine("{");
            }

            var firstMethod = methods.FirstOrDefault();
            var typeDecl = firstMethod?.Parent as TypeDeclarationSyntax;
            var isPartial = typeDecl?.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)) ?? false;

            if (isPartial)
            {
                var modifiers = GetTypeModifiers(typeDecl);
                sb.AppendLine($"    {modifiers}partial class {shortTypeName}");
                sb.AppendLine("    {");

                foreach (var method in methods)
                {
                    GenerateTransformedMethod(sb, method, "        ");
                }

                sb.AppendLine("    }");
            }
            else
            {
                sb.AppendLine($"    /// <summary>");
                sb.AppendLine($"    /// Continuation-enabled versions of {shortTypeName} methods.");
                sb.AppendLine($"    /// </summary>");
                sb.AppendLine($"    public static class {shortTypeName}Continuations");
                sb.AppendLine("    {");

                foreach (var method in methods)
                {
                    GenerateStaticTransformedMethod(sb, method, shortTypeName, "        ");
                }

                sb.AppendLine("    }");
            }

            if (!string.IsNullOrEmpty(ns))
            {
                sb.AppendLine("}");
            }

            return sb.ToString();
        }

        private static string GetTypeModifiers(TypeDeclarationSyntax typeDecl)
        {
            var sb = new StringBuilder();
            foreach (var mod in typeDecl.Modifiers)
            {
                if (mod.IsKind(SyntaxKind.PartialKeyword)) continue;
                sb.Append(mod.Text);
                sb.Append(' ');
            }
            return sb.ToString();
        }

        private static void GenerateTransformedMethod(StringBuilder sb, MethodDeclarationSyntax method, string indent)
        {
            var methodName = method.Identifier.Text;
            var returnType = method.ReturnType.ToString();
            var parameters = method.ParameterList.ToString();
            var isVoid = returnType == "void";
            var methodToken = GenerateMethodToken(method);

            var analyzer = new YieldPointAnalyzer();
            var yieldPoints = analyzer.FindYieldPoints(method);
            var locals = GetLocalVariables(method);

            sb.AppendLine();
            sb.AppendLine($"{indent}/// <summary>");
            sb.AppendLine($"{indent}/// Continuation-enabled version of {methodName}.");
            sb.AppendLine($"{indent}/// Supports suspension at {yieldPoints.Count} yield point(s).");
            sb.AppendLine($"{indent}/// </summary>");
            sb.AppendLine($"{indent}public {returnType} {methodName}_Continuable{parameters}");
            sb.AppendLine($"{indent}{{");

            GenerateStateMachineBody(sb, method, yieldPoints, locals, methodToken, indent + "    ", isVoid, returnType);

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateStaticTransformedMethod(StringBuilder sb, MethodDeclarationSyntax method, string originalTypeName, string indent)
        {
            var methodName = method.Identifier.Text;
            var returnType = method.ReturnType.ToString();
            var isStatic = method.Modifiers.Any(m => m.IsKind(SyntaxKind.StaticKeyword));
            var isVoid = returnType == "void";
            var methodToken = GenerateMethodToken(method);

            var analyzer = new YieldPointAnalyzer();
            var yieldPoints = analyzer.FindYieldPoints(method);
            var locals = GetLocalVariables(method);

            var paramList = method.ParameterList.Parameters.ToString();
            if (!isStatic)
            {
                paramList = string.IsNullOrWhiteSpace(paramList)
                    ? $"{originalTypeName} instance"
                    : $"{originalTypeName} instance, {paramList}";
            }

            sb.AppendLine();
            sb.AppendLine($"{indent}/// <summary>");
            sb.AppendLine($"{indent}/// Continuation-enabled wrapper for {originalTypeName}.{methodName}.");
            sb.AppendLine($"{indent}/// Supports suspension at {yieldPoints.Count} yield point(s).");
            sb.AppendLine($"{indent}/// </summary>");
            sb.AppendLine($"{indent}public static {returnType} {methodName}_Continuable({paramList})");
            sb.AppendLine($"{indent}{{");

            GenerateStateMachineBody(sb, method, yieldPoints, locals, methodToken, indent + "    ", isVoid, returnType);

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateStateMachineBody(
            StringBuilder sb,
            MethodDeclarationSyntax method,
            System.Collections.Generic.List<YieldPointInfo> yieldPoints,
            System.Collections.Generic.List<(string name, string type)> locals,
            int methodToken,
            string indent,
            bool isVoid,
            string returnType)
        {
            sb.AppendLine($"{indent}var __context = ScriptContext.EnsureCurrent();");
            sb.AppendLine($"{indent}const int __methodToken = {methodToken};");
            sb.AppendLine($"{indent}int __state = 0;");
            sb.AppendLine();

            // Declare all locals at outer scope
            foreach (var local in locals)
            {
                sb.AppendLine($"{indent}{local.type} {local.name} = default({local.type});");
            }
            sb.AppendLine();

            // Restore block - set state from frame
            sb.AppendLine($"{indent}// Restore state if resuming");
            sb.AppendLine($"{indent}if (__context.IsRestoring && __context.FrameChain?.MethodToken == __methodToken)");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    var __frame = __context.FrameChain;");
            sb.AppendLine($"{indent}    __context.FrameChain = __frame.Caller;");
            sb.AppendLine($"{indent}    __state = __frame.YieldPointId + 1; // Resume after yield point");
            sb.AppendLine();

            // Restore locals from slots
            for (int i = 0; i < locals.Count; i++)
            {
                var local = locals[i];
                sb.AppendLine($"{indent}    {local.name} = FrameCapture.GetSlot<{local.type}>(__frame.Slots, {i});");
            }
            sb.AppendLine();

            sb.AppendLine($"{indent}    if (__context.FrameChain == null)");
            sb.AppendLine($"{indent}        __context.IsRestoring = false;");
            sb.AppendLine($"{indent}}}");
            sb.AppendLine();

            // Try block with state machine
            sb.AppendLine($"{indent}try");
            sb.AppendLine($"{indent}{{");

            // For now, generate a simplified version that just calls the original method
            // A full implementation would transform the body into a state machine
            sb.AppendLine($"{indent}    // State machine implementation");
            sb.AppendLine($"{indent}    // Note: This simplified version wraps the original logic.");
            sb.AppendLine($"{indent}    // A full implementation would transform loops into state transitions.");
            sb.AppendLine();

            // Generate simplified body with yield checks
            GenerateSimplifiedBody(sb, method, yieldPoints, indent + "    ");

            sb.AppendLine($"{indent}}}");

            // Catch block for state capture
            sb.AppendLine($"{indent}catch (SuspendException __ex)");
            sb.AppendLine($"{indent}{{");
            sb.Append($"{indent}    var __slots = FrameCapture.PackSlots(");
            if (locals.Count > 0)
            {
                sb.Append(string.Join(", ", locals.Select(l => l.name)));
            }
            sb.AppendLine(");");
            sb.AppendLine($"{indent}    var __record = FrameCapture.CaptureFrame(__methodToken, __ex.YieldPointId, __slots, __ex.FrameChain);");
            sb.AppendLine($"{indent}    __ex.FrameChain = __record;");
            sb.AppendLine($"{indent}    throw;");
            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateSimplifiedBody(
            StringBuilder sb,
            MethodDeclarationSyntax method,
            System.Collections.Generic.List<YieldPointInfo> yieldPoints,
            string indent)
        {
            var body = method.Body;
            if (body == null)
            {
                // Expression-bodied method
                var arrow = method.ExpressionBody;
                if (arrow != null)
                {
                    sb.AppendLine($"{indent}return {arrow.Expression};");
                }
                return;
            }

            int yieldPointIndex = 0;

            foreach (var statement in body.Statements)
            {
                // Check if this is a loop statement - add yield point before
                if (statement is WhileStatementSyntax ||
                    statement is ForStatementSyntax ||
                    statement is ForEachStatementSyntax ||
                    statement is DoStatementSyntax)
                {
                    sb.AppendLine($"{indent}// Yield point {yieldPointIndex} (loop)");
                    sb.AppendLine($"{indent}__context.HandleYieldPoint({yieldPointIndex});");
                    yieldPointIndex++;
                }

                // Output the statement, handling local declarations specially
                if (statement is LocalDeclarationStatementSyntax localDecl)
                {
                    // Don't redeclare - just assign
                    foreach (var variable in localDecl.Declaration.Variables)
                    {
                        if (variable.Initializer != null)
                        {
                            sb.AppendLine($"{indent}{variable.Identifier.Text} = {variable.Initializer.Value};");
                        }
                    }
                }
                else
                {
                    sb.AppendLine($"{indent}{statement.ToFullString().TrimEnd()}");
                }
            }
        }

        private static System.Collections.Generic.List<(string name, string type)> GetLocalVariables(MethodDeclarationSyntax method)
        {
            var locals = new System.Collections.Generic.List<(string name, string type)>();

            if (method.Body == null) return locals;

            foreach (var statement in method.Body.Statements)
            {
                if (statement is LocalDeclarationStatementSyntax localDecl)
                {
                    var typeName = localDecl.Declaration.Type.ToString();
                    // Handle var keyword
                    if (typeName == "var")
                    {
                        typeName = "object"; // Simplified - real impl would infer type
                    }
                    foreach (var variable in localDecl.Declaration.Variables)
                    {
                        locals.Add((variable.Identifier.Text, typeName));
                    }
                }
            }

            return locals;
        }

        private static int GenerateMethodToken(MethodDeclarationSyntax method)
        {
            var typeName = GetFullTypeName(method);
            var methodName = method.Identifier.Text;
            var parameters = string.Join(",", method.ParameterList.Parameters.Select(p => p.Type?.ToString() ?? ""));

            unchecked
            {
                int hash = 17;
                hash = hash * 31 + (typeName?.GetHashCode() ?? 0);
                hash = hash * 31 + (methodName?.GetHashCode() ?? 0);
                hash = hash * 31 + (parameters?.GetHashCode() ?? 0);
                return hash;
            }
        }
    }
}
